{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © www.itheima.com/javase 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-10-12 02:02:19 "},"MIT Missing Semester 笔记/Command-line-Environment.html":{"url":"MIT Missing Semester 笔记/Command-line-Environment.html","title":"Command Line Environment","keywords":"","body":"任务控制（Job Control） 大多数情况下我们中断执行中的任务都是使用Ctrl+c来强制停止进程。这里我们研究一下它的工作原理。 结束进程 Shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种软件中断。 当我们键入Ctrl+c的时候，Shell 会发送SIGINT的信号（Signal Interrupt），来让程序停止运行。 信号列表：（我在虚拟机的 Linux 命令行上输入 man signal 后并没有列出各个信号的名字和描述，故在此放出来） No Name Default Action Description 1 SIGHUP terminate process terminal line hangup 2 SIGINT terminate process interrupt program 3 SIGQUIT create core image quit program 4 SIGILL create core image illegal instruction 5 SIGTRAP create core image trace trap 6 SIGABRT create core image abort program (formerly SIGIOT) 7 SIGEMT create core image emulate instruction executed 8 SIGFPE create core image floating-point exception 9 SIGKILL terminate process kill program 10 SIGBUS create core image bus error 11 SIGSEGV create core image segmentation violation 12 SIGSYS create core image non-existent system call invoked 13 SIGPIPE terminate process write on a pipe with no reader 14 SIGALRM terminate process real-time timer expired 15 SIGTERM terminate process software termination signal 16 SIGURG discard signal urgent condition present on socket 17 SIGSTOP stop process stop (cannot be caught or ignored) 18 SIGTSTP stop process stop signal generated from keyboard 19 SIGCONT discard signal continue after stop 20 SIGCHLD discard signal child status has changed ... 这里有一个使用Python脚本来捕获SIGINT信号并且忽视它的例子，因为捕获了信号，所以不会导致程序停止。想要停止程序需要使用SIGQUIT，输入Ctrl+\\即可。 #!/usr/bin/env python import signal, time def handler(signum, time): print(\"\\nI got a SIGINT, but I am not stopping\") signal.signal(signal.SIGINT, handler) i = 0 while True: time.sleep(.1) print(\"\\r{}\".format(i), end=\"\") i += 1 我们向这个程序发送两次SIGINT，然后再发送一次SIGQUIT。注意，^是我们在终端输入Ctrl时的表示形式。 $ python sigint.py 24^C I got a SIGINT, but I am not stopping 26^C I got a SIGINT, but I am not stopping 30^\\[1] 39913 quit python sigint.py 无法捕获的信号有SIGKILL等，通常情况下，此种信号终止的进程可能会残留子进程，子进程在没有主进程的情况下可能会产生不可预料的行为。 尽管SIGINT和SIGQUIT都是常用的终止程序的终端请求，一个更常用的用来停止程序的信号是SIGTERM。我们需要使用kill命令发送这个信号，语法是kill -TERM 。 暂停和后台执行进程 信号除了杀死进程之外还能做一些其他的事情。例如，SIGSTOP会让进程暂停。在终端中，键入Ctrl+Z会让 Shell 发送SIGTSTP信号，SIGTSTP是Terminal Stop的缩写（即terminal版本的SIGSTOP）。 我们可以使用fg或bg命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。 jobs命令会列出当前终端会话当中没有结束的任务。你可以使用任务的 pid 来指代这些任务（也可以使用pgrep来找出pid）。你也可以使用百分号%加上任务编号来指代任务，这样更加符合直觉（jobs命令会打印出任务编号）。你也可以使用$!指代最近的一个任务。 在 Shell 命令中添加&后缀可以让命令在直接在后台运行，这使得你可以直接在 Shell 中继续做其他操作，不过它此时还是会使用 Shell 的标准输出。这点有的时候比较麻烦，可以使用重定向进行处理。 让已经在运行的进程转到后台运行，你可以键入Ctrl+Z，然后紧接着再输入bg。注意，后台的进程仍然是你的终端进程的子进程，一旦你关闭终端（会发送另外一个信号SIGHUP），这些后台的进程也会终止。为了防止这种情况发生，你可以使用nohup(一个用来忽略SIGHUP的封装) 来运行程序。针对已经运行的程序，可以使用disown。除此之外，你还可以使用终端多路复用器来实现。 下面是展示了刚才这些概念的简单例子： $ sleep 1000 ^Z [1] + 18653 suspended sleep 1000 $ nohup sleep 2000 & [2] 18745 appending output to nohup.out $ jobs [1] + suspended sleep 1000 [2] - running nohup sleep 2000 $ bg %1 [1] - 18653 continued sleep 1000 $ jobs [1] - running sleep 1000 [2] + running nohup sleep 2000 $ kill -STOP %1 [1] + 18653 suspended (signal) sleep 1000 $ jobs [1] + suspended (signal) sleep 1000 [2] - running nohup sleep 2000 $ kill -SIGHUP %1 [1] + 18653 hangup sleep 1000 $ jobs [2] + running nohup sleep 2000 $ kill -SIGHUP %2 $ jobs [2] + running nohup sleep 2000 $ kill %2 [2] + 18745 terminated nohup sleep 2000 $ jobs $ 终端多路复用（Terminal Multiplexers） 在使用终端的时候，你通常会同时执行多个任务。比如你想要同时编辑代码和运行程序。尽管打开一个新的终端窗口也能实现，但使用终端多路复用器是一个更好的解决方案。 像tmux这类的终端多路复用器可以允许我们基于面板(pane)和标签(tab)分割出多个终端窗口，这样你便可以同时与多个 Shell 会话(session)进行交互。 终端多路复用还可以让我们可以挂起当前终端会话并在将来重新连接。 这让你操作远端设备时的工作流大大改善，避免了使用nohup或是其他类似的操作。 目前最流行的终端多路复用器是tmux，tmux可以高度定制，通过快捷键可以创建多个标签页（tab）以及快速在它们之间导航。 tmux的快捷键需要我们掌握，它们都是类似Ctrl+b x这样的组合，即需要先按下Ctrl+b，松开后再按下x。tmux中对象的继承结构如下： 会话（Session）- 每个会话都是一个独立的工作区，其中包含一个或多个窗口 tmux 开始一个新的会话 tmux new -s NAME 以指定名称开始一个新的会话 tmux ls 列出当前所有会话 在tmux中输入Ctrl+b d，将当前会话挂起 tmux a重新连接最后一个会话。可用-t来指定具体的会话 窗口（Window）- 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分 Ctrl+b c创建一个新的窗口，使用Ctrl+d关闭 Ctrl+b N 跳转到第 N 个窗口，注意每个窗口都是有编号的 Ctrl+b p 切换到前一个窗口 Ctrl+b n 切换到下一个窗口 Ctrl+b , 重命名当前窗口 Ctrl+b w 列出当前所有窗口 面板（Pane）- 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 Shell Ctrl+b \" 水平分割 Ctrl+b % 垂直分割 Ctrl+b 切换到指定方向的面板， 指的是键盘上的方向键 Ctrl+b z 切换当前面板的缩放 Ctrl+b [ 开始往回卷动屏幕。你可以按下空格键来开始选择，回车键复制选中的部分 Ctrl+b 在不同的面板排布间切换 扩展阅读：这里是一份 tmux 快速入门教程，而这一篇 文章则更加详细，它包含了screen命令。你也许想要掌握screen命令，因为在大多数 UNIX 系统中都默认安装有该程序。 中文教程： Tmux 使用教程 Linux命令之screen命令 别名 有的时候输入比较长的命令比较麻烦，尤其是涉及多许多 flag 和选项的时候。出于简化的目的，大多数 Shell 都支持别名。Shell 中的别名相当于长命令的缩写形式，Shell 会自动将其替换成原本的命令。比如，bash中的别名语法如下： alias alias_name=\"command_to_alias arg1 arg2\" 注意， =两边是没有空格的，因为alias是一个 Shell 命令，它只接受一个参数。 别名有许多很方便的特性: # 创建常用命令的缩写 alias ll=\"ls -lh\" # 能够少输入很多 alias gs=\"git status\" alias gc=\"git commit\" alias v=\"vim\" # 手误打错命令也没关系 alias sl=ls # 重新定义一些命令行的默认行为 alias mv=\"mv -i\" # -i prompts before overwrite alias mkdir=\"mkdir -p\" # -p make parent dirs as needed alias df=\"df -h\" # -h prints human readable format # 别名可以组合使用 alias la=\"ls -A\" alias lla=\"la -l\" # 在忽略某个别名 \\ls # 或者禁用别名 unalias la # 获取别名的定义 alias ll # 会打印 ll='ls -lh' +++ 更改 Shell 的名字 Shell 的名字也是一个环境变量，你可以更改其提示字符串 bash-5.0$ PS1=\"> \" > exit +++ 注意：默认情况下，别名在 Shell 中并不会永久保存，为了让别名永久生效，你可以将配置写入 Shell 的启动配置文件当中，比如.bashrc或.zshrc。 Linux中如何使用alias命令 配置文件（Dotfiles） 很多程序的配置都是通过纯文本格式的被称作点文件（dotfiles）的配置文件来完成的（之所以称为点文件，是因为它们的文件名以.开头，例如~/.vimrc。也正因为此，它们默认是隐藏文件，单纯的ls并不会显示它们）。 Shell 也是使用 点文件 进行配置的程序。在启动的时候，Shell 会读取很多文件来载入配置。根据 Shell 的不同，你是否登录或者是否以交互的形式开始，这个过程会有很大的区别并且非常复杂。关于这个话题，这里有一个很好的资源。 对于 Bash 来说，在大多数系统下，你需要编辑.bashrc或者.bash_profile来进行配置。在文件当中，你可以添加需要在启动的时候执行的命令，比如 别名 或者 配置环境变量。 实际上，很多程序都会要求你在 Shell 的配置文件当中加入一行类似 export PATH=\"$PATH:/path/to/program/bin\"的配置。加入了之后，才能确保这些程序能够被 Shell 找到。 还有一些其他的工具也可以通过dotfile进行配置： bash - ~/.bashrc,~/.bash_profile git - ~/.gitconfig vim - ~/.vimrc 和 ~/.vim 目录 ssh - ~/.ssh/config tmux - ~/.tmux.conf 我们要怎么管理我们的 dotfile 呢？它们应该在它们独自的文件夹下，通过版本控制系统（version control）进行管理，通过脚本将其 符号链接（软链接）到需要的地方。这样做有这些好处： 安装简单: 如果你登录了一台新的设备，在这台设备上应用你的配置只需要几分钟的时间； 可以执行: 你的工具在任何地方都以相同的配置工作 同步: 在一处更新配置文件，可以同步到其他所有地方 变更追踪: 你可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的 dotfile 中需要放些什么？你可以通过在线文档和帮助手册（manual page）了解所使用工具的设置项。或者在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：你可以在这里找到无数的dotfiles 仓库 —— 其中最受欢迎的那些可以在这里找到。这里 也有一些非常有用的资源。 我们希望你不是仅仅复制粘贴，而是能花点时间阅读一下配置文件当中的细节， 理解这些配置存在的意义以及这么配置的原因。（这里需要你有一定的英语基础） 本课程的老师们也在 GitHub 上开源了他们的配置文件：Anish, Jon, Jose. 可移植性 dotfile 的一个常见痛点是它并不能在不同的设备上生效，如你在不同设备上使用的操作系统或者 Shell 是不一样的，那配置文件是无法生效的。有的时候你可能也会想让特定的配置只在某些设备上生效。 有一些技巧可以轻松达成这些目的。如果配置 if 语句，则你可以借助它针对不同的设备编写不同的配置。例如，你的 shell 可以这样做： if [[ \"$(uname)\" == \"Linux\" ]]; then {do_sth}; fi # 使用和 shell 相关的配置时先检查当前 shell 类型 if [[ \"$SHELL\" == \"zsh\" ]]; then {do_sth}; fi # 针对特定设备进行配置 if [[ \"$(hostname)\" == \"myServer\" ]]; then {do_sth}; fi 如果配置文件支持 include 功能，你也可以使用include，比如~/.gitignore可以这样编写： [include] path = ~/.gitconfig_local 对于每台机器来说，~/.gitconfig_local可以包含独有的一些配置。你甚至可以创建一个专门的代码仓库来追踪管理这些特定的配置。 在你想要不同的程序共享某些配置的时候，这个思路也一样有用。比如，你想要让bash和zsh中同时启用一些别名，你可以将这些别名写在.aliases当中，然后在这两个 Shell 的配置当中加上： # Test if ~/.aliases exists and source it if [ -f ~/.aliases ]; then source ~/.aliases fi 远端连接（Remote Machines） 对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果需要使用远程服务器来部署后端程序或需要一个高性能计算的服务器，你就会用到 Secure Shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。 通过如下命令，你可以使用 ssh 连接到其他服务器： ssh foo@bar.mit.edu 这里的foo是用户名，bar.mit.edu是服务器地址。服务器地址可以是域名也可以是 IP。之后我们将会看到进行 ssh 的配置之后，我们可以仅仅使用 ssh bar 来进行登录。 执行命令 ssh 一个经常被忽略的功能是直接执行命令。 ssh foobar@server ls将会在foobar设备中home目录下执行ls命令。 管道命令同样有效，所以ssh foobar@server ls | grep PATTERN将会本地grep远程命令ls获取的结果。ls | ssh foobar@server grep PATTERN将会在远端grep本地命令ls得到的结果。 SSH Keys 基于 key 的验证机制使用了密码学中的公钥来向服务器证明用户持有对应的私钥，而不需要公开其私钥。 使用这种方法可以避免每次登录都输入密码。不过，私钥相当于你的密码，你需要保管好它。通常存放在~/.ssh/id_rsa或者~/.ssh/id_ed25519。 Key 生成 使用 ssh-keygen 命令可以生成公钥和私钥： ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519 你可以为私钥设置密码，这样可以防止别人用你的私钥访问你的服务器。你可以使用 ssh-agent 或 gpg-agent ，这样就不需要每次都输入该密码了。 若你配置过 SSH Key 推送到 GitHub，那么你就已经完成了这里介绍的步骤，并且已经有了一对密钥。要检查你是否持有密码并验证它，你可以使用这个命令ssh-keygen -y -f /path/to/key。 基于 Key 的认证机制 ssh 将会查找.ssh/authorized_keys来决定允许哪些用户访问。你可以使用命令将你的公钥拷贝到服务器上： cat .ssh/id_ed25519 | ssh foobar@remote 'cat >> ~/.ssh/authorized_keys' 如果支持ssh-copy-id的话，可以使用下面这个更简单的命令： ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote 通过 SSH 复制文件 使用 ssh 复制文件有很多方法： ssh + tee, 最简单的方法是执行 ssh 命令，然后通过这样的方法利用标准输入实现 cat localfile | ssh remote_server tee serverfile。tee 命令会将标准输出写入到一个文件； scp ：当需要拷贝大量的文件或目录时，使用scp命令会更方便，因为它可以遍历相关路径。语法如下：scp path/to/local_file remote_host:path/to/remote_file； rsync 对 scp 进行了改进，它可以检测本地环境和远程服务器的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 --partial标记实现断点续传。rsync的语法和scp类似； 端口转发（Port Forwarding） 在许多场景当中，你将会运行一些监听某些端口的程序。当你在本地运行的时候，你可以使用localhost:PORT或者127.0.0.1:PORT。但当你在服务器上运行时你该如何操作呢？服务器上的端口通常不会通过网络暴露给你。 此时就需要进行端口转发。端口转发有两种：本地端口转发和远程端口转发。（参见下图，该图片引用自这篇 StackOverflow 文章） 本地端口转发（Local Port Forwarding） 远程端口转发（Remote Port Forwarding） 最常用的是本地端口转发，即远端服务器上的服务监听了一个端口，你希望将本地设备的一个端口和远程的端口连接起来。 举个例子，如果我们在远程服务器上的8888端口运行了一个jupyter notebook。然后我们建立本地9999端口的转发，使用ssh -L 9999:localhost:8888 foobar@remote_server。这样一来，我们只需要访问本地的localhost:9999端口即可。 SSH 配置 我们已经介绍了许多参数，为了快捷，我们可以为它们创建别名，例如： alias my_server=\"ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server\" 一劳永逸的方法是配置 config 文件（一般的路径为~/.ssh/config）： Host vm User foobar HostName 172.16.174.141 Port 2222 IdentityFile ~/.ssh/id_ed25519 LocalForward 9999 localhost:8888 # 在配置文件中也可以使用通配符 Host *.mit.edu User foobar 使用~/.ssh/config来创建别名，可以让scp、rsync、mosh等等命令都可以读取这个配置并进行利用。 注意，~/.ssh/config也是一个 dotfile ，一般情况下也可以被导入其他配置文件。如果你公开到互联网上，那么其他人也能看到你的一些潜在信息，比如服务器、用户名、开放端口等等，这可能会帮助到那些想要入侵你的黑客，请务必小心。 远程服务器端的配置文件一般位于 /etc/ssh/sshd_config，你可以在其中配置诸如 取消密码验证、修改 ssh 端口、开启 X11 转发 等等。你可以针对每一个用户进行单独设置。 杂项 远程连接服务器的其中一个常见痛点是，当网络环境发生变化、电脑关机/睡眠时会导致断开连接。并且如果连接的延迟很高也很让人绝望。Mosh（mobile shell）对 ssh 进行了改进，允许连接漫游、间歇连接以及智能本地回显等等功能。 有时将远程的文件夹挂载到本地会比较方便，sshfs可以将远程服务器中的一个文件夹挂载到本地，这样你就可以使用本地编辑器进行访问了。 Shell & 框架 在 shell 工具和脚本那节课中我们已经介绍了 bash shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。 例如，zsh shell 是 bash 的超集并提供了一些方便的功能： 智能替换, ** 行内替换/通配符扩展 拼写纠错 更好的 tab 补全和选择 路径展开 (cd /u/lo/b 会被展开为 /usr/local/bin) 框架也可以改进你的 shell。比较流行的通用框架包括prezto或oh-my-zsh。还有一些更精简的框架，它们往往专注于某一个特定功能，例如zsh 语法高亮 或 zsh 历史子串查询。 像 fish 这样的 shell 包含了很多用户友好的功能，其中一些特性包括： 向右对齐 命令语法高亮 历史子串查询 基于手册页面的选项补全 更智能的自动补全 提示符主题 需要注意的是，使用这些框架可能会降低 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。你随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。 终端模拟器（Terminal Emulators） 和自定义 shell 一样，花点时间选择适合你的终端模拟器并进行设置是很有必要的。有许多终端模拟器可供你选择（这里有一些关于它们之间比较的信息） 你会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，你可以从下面这些方面来配置你的终端： 字体选择 彩色主题 快捷键 标签页/面板支持 回退配置 性能（像 Alacritty 或者 kitty 这种比较新的终端，它们支持GPU加速） 课后练习 任务控制 我们可以使用类似ps aux | grep这样的命令来获取任务的 pid ，然后您可以基于pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 sleep 10000 这个任务。然后用 Ctrl+z 将其切换到后台并使用 bg 来继续允许它。现在，使用 pgrep 来查找 pid 并使用 pkill 结束进程而不需要手动输入pid。(提示：: 使用 -af 标记)。 PS: 这里虚拟机表示-a为无效选项，查看帮助后发现没有-a选项，所以只用了-f。 -a Include process ancestors in the match list. By default, the current pgrep or pkill process and all of its ancestors are excluded (unless -v is used). 包含匹配列表中的父进程。默认为目前执行 pgrep 或 pkill 命令的进程以及其所有父进程（除非使用了 -v） -f Match against full argument lists. The default is to match against process names. 匹配所有参数列表。默认只匹配进程名称。 如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？在这个练习中，我们使用 sleep 60 & 作为先执行的程序。一种方法是使用 wait 命令。尝试启动这个休眠命令，然后待其结束后再执行 ls 命令。 sleep 60 & pgrep sleep | wait; ls 但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 wait 只能对子进程起作用。之前我们没有提过的一个特性是，kill 命令成功退出时其状态码为 0 ，其他状态则是非0。kill -0 则不会发送信号，但是会在进程不存在时返回一个不为 0 的状态码。请编写一个 bash 函数 pidwait ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 sleep 来避免浪费 CPU 性能。 #!/bin/bash pidwait() { while kill -0 $1 do sleep 1 done ls } 这里 while 判断的是命令行的返回值而不是布尔值，这个和其他语言有所区别。返回值 0 表示成功所以能够进入循环，参考这个问题 终端多路复用 请完成这个 tmux 教程 ，并参考这些步骤来学习如何自定义 tmux。 很好的一个教程，只需要一点英语基础就能看懂。 别名 创建一个 dc 别名，它的功能是当我们错误的将 cd 输入为 dc 时也能正确执行。 alias dc=cd 执行 history | awk '{$1=\"\";print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用 history 1 替换 history。 这里我的虚拟机是经常换来换去的，获取的数据不准确，可以依照个人习惯改别名。 配置文件 让我们帮助您进一步学习配置文件： 为您的配置文件新建一个文件夹，并设置好版本控制 在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 $PS1 开始）。 建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个 shell 脚本对每个文件使用 ln -s，也可以使用专用工具 在新的虚拟机上测试该安装脚本。 将您现有的所有配置文件移动到项目仓库里。 将项目发布到GitHub。 mkdir ~/dotfiles git init ~/dotfiles #!/bin/bash files=\"bashrc vimrc \" for file in $files; do ln -s ~/dotfiles/$file ~/.$file done 远端连接 前往 ~/.ssh/ 并查看是否已经存在 SSH 密钥对。如果不存在，请使用ssh-keygen -o -a 100 -t ed25519来创建一个。建议为密钥设置密码然后使用ssh-agent，更多信息可以参考 这里； 这里我本地电脑已经有密钥了，直接使用就行。 在.ssh/config加入下面内容： Host vm User username_goes_here HostName ip_goes_here IdentityFile ~/.ssh/id_ed25519 LocalForward 9999 localhost:8888 这里添加我的虚拟机，ssh配置如下： 使用 ssh-copy-id vm 将您的 ssh 密钥拷贝到服务器。 本地电脑为Windows，无法使用ssh-copy-id，故不进行免密登录。 使用python -m http.server 8888 在您的虚拟机中启动一个 Web 服务器并通过本机的http://localhost:9999 访问虚拟机上的 Web 服务器 PS：这里用的是低版本的python，所以指令有所不同 使用sudo vim /etc/ssh/sshd_config 编辑 SSH 服务器配置，通过修改PasswordAuthentication的值来禁用密码验证。通过修改PermitRootLogin的值来禁用 root 登录。然后使用sudo service sshd restart重启 ssh 服务器，然后重新尝试。 这里本地Windows没有用免密验证，所以跳过此题。 (附加题) 在虚拟机中安装 mosh 并启动连接。然后断开服务器/虚拟机的网络适配器。mosh可以恢复连接吗？ 使用 Mosh 来优化 SSH 连接 (附加题) 查看 ssh 的-N 和 -f 选项的作用，找出在后台进行端口转发的命令是什么？ -N Do not execute a remote command. This is useful for just forwarding ports. -f Requests ssh to go to background just before command execution. This is useful if ssh is going to ask for passwords or passphrases, but the user wants it in the background. This implies -n. The recommended way to start X11 programs at a remote site is with something like ssh -f host xterm. If the ExitOnForwardFailure configuration option is set to ``yes'', then a client started with -f will wait for all remote port forwards to be successfully established before placing itself in the background. -N 就是不执行远端命令，适用于端口转发的情况 -f 是让 ssh 在执行命令前切换到后台运行 后台进行端口转发的命令: ssh -fN -L 9999:localhost:8888 vm Copyright © www.itheima.com/javase 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-10-09 00:24:30 "},"MIT Missing Semester 笔记/Course-Overview-and-The-Shell.html":{"url":"MIT Missing Semester 笔记/Course-Overview-and-The-Shell.html","title":"Course Overview And The Shell","keywords":"","body":"官方文档: https://missing.csail.mit.edu/ 官方文档中文翻译: https://missing-semester-cn.github.io/ 为什么要上这门课？ 作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。 但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。 在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令，或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。 本课程为了解决这个问题，将向您展示一些您在日常工作和学习中可以使用的工具，挖掘它们的潜力。我们将教会您如何充分利用您所知道的工具，并教授一些您所不知道的新工具。 在课程中将会展示如何同时使用多个工具来制造出您所想象不到的东西。 课程结构 见官方文档或该文档的汉化版。 The Shell 什么是 Shell 当您想在电脑图形界面所允许的行为上做更多的事情时，Shell将会是您和电脑交互的主要方式。图形界面在大多数的时候都是受限制的（我认为这是对于开发人员来说的）。 而基于文本的工具通常是能互相耦合的，也有无数种方法能将它们结合起来，或者用程序使其可以自动化。Shell则是您去实现这些方法的工具。 几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。 这里的Shell可以理解为命令行界面(CLI, Command Line Interface)。 本节课我们会使用 Bourne Again Shell, 简称 “bash” 。 这是被最广泛使用的一种shell，它的语法和其他的shell都是类似的。打开shell提示符（命令行提示符），您首先需要打开终端(Terminal) 。您的设备通常都已经内置了终端(Terminal)，或者您也可以安装一个，非常简单。 使用 Shell 当您打开终端时，它通常看起来是这样的： Username@Hostname:~$ Username即是您的用户名，如您作为root登入，该处显示为root hostname为您的主机名，这里显示您的主机名称。 ~的位置符号表示当前的工作目录（“current working directory”）或者说您当前所在的位置(~表示 “home目录”)。 $符号表示您目前的身份为非root用户。root用户显示为#。 这个提示符是可以自定义的，但是默认的一般都是这样。 这是您电脑上和Shell交互的主要文本界面，您可以在命令行提示符上输入命令(command)。 如： Username@Hostname:~$ echo hello hello echo是用来打印您传给它的参数的程序，而参数(argument)是一些紧随程序名后面且用空格分隔开的文本。 如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 \\ 进行处理（My\\ Photos）。 Shell 是如何运行这些程序的？ Shell，或者说 bash 本身就是一种程序设计语言，您输入的提示符(Prompl)不仅能带参运行程序，您也可以写出 while 循环、for 循环、条件等等，甚至可以定义函数或者变量。 类似于 Python 或 Ruby，Shell 是一个编程环境，所以它具备变量、条件、循环和函数。当你在 shell 中执行命令时，您实际上是在执行一段 Shell 可以解释执行的简短代码。如果你要求 Shell 执行某个指令，但是该指令并不是 Shell 所了解的编程关键字，那么它会去咨询 环境变量(Environment Variable) $PATH，它会列出当 shell 接到某条指令时，进行程序搜索的路径： Username@Hostname:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Username@Hostname:~$ whcih echo /bin/echo Username@Hostname:~$ /bin/echo hello hello 当我们执行 echo 命令时，Shell 了解到需要执行 echo 这个程序，随后它便会在$PATH中搜索由 : 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是可执行程序）。确定某个程序名代表的是哪个具体的程序，可以使用which程序。我们也可以绕过$PATH，通过直接指定需要执行的程序的路径来执行该程序。 在Shell中导航 Shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用/分割，而在Windows上是\\。路径/代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如：C:\\）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以/开头，那么它是一个绝对路径，其他的都是相对路径。 绝对路径是可以绝对精准地确定一个文件的位置的路径，相对路径是相对于您当前所在位置的路径。 要找出我们当前所在的位置在哪里，我们可以使用pwd(print working directory)。在bash中输入pwd，它就会输出当前所在的目录路径： Username@Hostname:~/missing$ pwd /home/missing Username@Hostname:~/missing$ cd .. Username@Hostname:~$ pwd /home Username@Hostname:~$ cd .. Username@Hostname:/$ pwd / Username@Hostname:/$ cd ./home Username@Hostname:~$ cd missing Username@Hostname:~/missing$ pwd /home/missing Username@Hostname:~/missing$ ../../bin/echo hello hello 切换目录需要使用cd命令。在路径中，.表示的是当前目录，而..表示上级目录。 一般情况下，使用命令行运行程序时，程序会默认在当前目录运行，除非您再给程序指定了一个路径。 查看当前目录下包含的文件，可以使用ls命令： Username@Hostname:~/missing$ ls Username@Hostname:~/missing$ cd .. Username@Hostname:~$ ls missing Username@Hostname:~$ cd missing/ Username@Hostname:~/missing$ ls .. missing Username@Hostname:~/missing$ cd / Username@Hostname:/$ ls bin boot dev etc home ... Username@Hostname:/$ cd ~/missing Username@Hostname:~/missing$ cd - / Username@Hostname:/$ cd -命令为从当前目录跳转到您之前工作的上一个目录。 除非我们利用第一个参数指定目录，否则ls会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以-开头，并可以改变程序的行为。通常，在执行程序时使用-h或--help标记可以打印帮助信息，以便了解有哪些可用的标记或选项。 在帮助信息中，...代表可不填或者输入一个或以上的值，[]代表选项。 ls -l或ll表示采用长列表的形式输出信息。表现形式如下： Username@Hostname:~$ ls -l drwxr-xr-x 1 root users 4096 July 15 2022 missing 这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符d表示 missing 是一个目录。然后接下来的九个字符，每三个字符构成一组(rwx)。 三组从左到右分别代表了文件所有者（root），用户组（users） 以及其他所有人具有的权限。其中-表示该用户不具备相应的权限。 从上面的信息来看，只有文件所有者可以修改或者写入（w）missing 文件夹 （例如添加或删除文件夹中的文件）。 为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：x权限表示）。 为了列出它的包含的内容，用户必须对该文件夹具备读取权限（r）。对于文件来说，权限的意义也是类似的。 注意，/bin 目录下的程序在最后一组，即表示所有人的用户组中，均包含x权限，也就是说任何人都可以执行这些程序。 重命名、移动、复制、删除文件以及新建文件夹 mv命令后面通常会跟随两个路径（path）作为参数，第一个是原有路径，第二个是新的路径。 这也代表着mv既可以让你重命名一个文件（在原有位置），也可以让你将文件移动到另一个目录里。 例如： Username@Hostname:~/missing$ ls test.txt Username@Hostname:~/missing$ mv test.txt test1.txt Username@Hostname:~/missing$ ls test1.txt Username@Hostname:~/missing$ mv test1.txt ../test Username@Hostname:~/missing$ cd ../test Username@Hostname:~/test$ ls test1.txt cp（copy）命令可以将文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。 例如： Username@Hostname:~/test$ cp test1.txt ../missing/test.txt Username@Hostname:~/test$ ls test1.txt Username@Hostname:~/test$ cd ../missing Username@Hostname:~/missing$ ls test.txt rm为remove的缩写，rm命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。rm是一个危险的命令，使用的时候要特别当心,在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西。 例如： Username@Hostname:~/missing$ rm ../test/test1.txt Username@Hostname:~/missing$ ls ../test Username@Hostname:~/missing$ 删除一个目录中的一个或多个文件或目录，如欲删除目录必须加上参数-r，否则预设仅会删除文件。如果使用rm来删除文件，通常仍可以将该文件恢复原状。 mkdir命令用来创建目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由DirName（指定的文件名）命名的文件夹或目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 例如： Username@Hostname:~/missing$ mkdir test Username@Hostname:~/missing$ ll total 4 drwxr-xr-x. 2 root users 6 July 15 2022 test 如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试man这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用q可以退出该程序。 Username@Hostname:~/missing$ man ls man的意思是手册、说明书（manual pages），非内置程序。 手动输入clear或者同时按下Ctrl+l可清屏。 在程序间创建连接 如果您想把多个程序连接起来或者与文件交互，可以借助“流”（stream）来实现。 在 Shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 Shell提供了重定向这些“流”的方法，可将输入和输出都改到您所指定的地方。 最简单的重定向是和> file。这两个命令可以将程序的输入输出流分别重定向到文件： Username@Hostname:~/missing$ echo hello > hello.txt Username@Hostname:~/missing$ cat hello.txt hello Username@Hostname:~/missing$ cat hello2.txt Username@Hostname:~/missing$ cat hello2.txt hello 您还可以使用>>来向一个文件追加内容。使用管道（pipe），我们能够更好的利用文件重定向。|操作符允许我们将一个程序的输出和另外一个程序的输入连接起来： Username@Hostname:~/missing$ cat > hello2.txt Username@Hostname:~/missing$ cat hello2.txt hello hello Username@Hostname:~/missing$ ls -l / | tail -n1 drwxr-xr-x 1 root root 4096 Jun 20 2022 var Username@Hostname:~/missing$ ls -l / | tail -n1 > ls.txt Username@Hostname:~/missing$ cat ls.txt drwxr-xr-x 1 root root 4096 Jun 20 2022 var Username@Hostname:~/missing$ curl --head --silent google.com | grep --i content-length Content-Length: 219 Username@Hostname:~/missing$ curl --head --silent google.com | grep --i content-length | cut --delimiter=' ' -f2 219 根用户（root） 在Linux和MacOS中有一个root用户，它相当于Windows的Administrator。 root用户被允许在系统上做出任意的行为，它几乎不受任何限制，可以创建、读取、更新和删除系统中的任何文件，相当于一种“超级用户”。 您通常不会以root用户登录系统，而是用您自己命名的用户登录并操作这个系统。 如果您想用root权限操作，可以使用sudo命令，su即为Super User的缩写。 有一件事情是您必须作为根用户才能做的，那就是向sysfs文件写入内容。系统被挂载在/sys下，sysfs文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。注意 Windows 和 macOS 没有这个文件。 例如，您笔记本电脑的屏幕亮度写在 brightness 文件中，它位于 /sys/class/backlight 通过将数值写入该文件，我们可以改变屏幕的亮度。您可能会这样尝试更改： $ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*' /sys/class/backlight/intel_backlight/brightness $ cd /sys/class/backlight/intel_backlight $ sudo echo 500 > brightness An error occurred while redirecting file 'brightness' open: Permission denied 显然，这样会得到一个错误信息。因为输入输出的重定向是通过Shell执行的，而echo等程序并不知道如|、、>等的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， Shell(权限为您的当前用户)在设置sudo echo前尝试打开brightness文件并写入，但是系统拒绝了 Shell 的操作因为此时 Shell 的权限不是root用户。 在Stackoverflow上，您可能见到过这样的命令： User@localhost:~$ # echo 1 > /sys/net/ipv4_forward 上述命令之所以能运行，是因为前面的#表明是以root权限运行整条命令。 切换到root用户也很简单，只需要简单的命令： User@localhost:~$ sudo su 回车后会让您输入密码，密码正确即可以root权限操作Shell。 操作完毕后输入exit即可返回原用户权限。 在不使用root权限去更改屏幕亮度，可以这样做： $ echo 500 | sudo tee brightness 500 tee命令用于将标准输入复制到每个指定文件，并显示到标准输出。tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 课后练习 在 /tmp 下新建一个名为 missing 的文件夹。 User@localhost:~$ cd /tmp User@localhost:/tmp$ mkdir missing User@localhost:/tmp$ ls ... missing ... 用man查看程序touch的使用手册。 $ man touch TOUCH(1) User Commands TOUCH(1) NAME touch - change file timestamps SYNOPSIS touch [OPTION]... FILE... DESCRIPTION ... 用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 User@localhost:/tmp$ cd missing User@localhost:/tmp/missing$ touch semester 将以下内容一行一行地写入 semester 文件： #!/bin/sh curl --head --silent https://missing.csail.mit.edu User@localhost:/tmp/missing$ echo '#!/bin/sh' > semester User@localhost:/tmp/missing$ echo \"curl --head --silent https://missing.csail.mit.edu\" >> semester User@localhost:/tmp/missing$ cat semester #!/bin/sh curl --head --silent https://missing.csail.mit.edu curl用法指南 尝试执行这个文件。例如，将该脚本的路径（./semester）输入到您的shell中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。 $ ./semester bash: permission denied: ./semester $ ls -l total 8 -rw-r--r-- 1 user user 61 July 20 19:39 semester 查看 chmod 的手册(例如，使用 man chmod 命令) $ man chmod chmod修改权限用法 使用 chmod 命令改变权限，使 ./semester 能够成功执行，不要使用 sh semester 来执行该程序。 $ chmod a=rwx semester $ ll total 8 -rwxrwxrwx 1 user user 61 July 20 19:39 semester 使用 | 和 > ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中 $ ./semester | grep last-modified > ~/last-modified.txt $ cat ~/last-modified.txt last-modified: Sat, 14 May 2022 10:50:11 GMT 写一段命令来从 /sys 中获取笔记本的电量信息，或者台式机 CPU 的温度。 $ cat /sys/class/power_supply/BAT1/capacity Copyright © www.itheima.com/javase 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-07-24 23:06:21 "},"MIT Missing Semester 笔记/Data-Wrangling.html":{"url":"MIT Missing Semester 笔记/Data-Wrangling.html","title":"Data Wrangling","keywords":"","body":":::info 本节课内容过于专业，因此大部分均为摘抄官方文档，少部分作补充说明。 ::: 数据整理解决的基本问题就是：把一种格式的数据转换成另一种。这不仅仅是图片格式之间的转换，还有文本文件、日志文件等等，将其转换成图表或者统计数据的格式。 简单来说，数据整理就是把一个数据以另一种方式表达。 在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。 例如这样一条命令 journalctl | grep -i intel，它会找到所有包含 intel(不区分大小写) 的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。 数据整理需要有用来整理的数据和相关的应用场景。 日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器： ssh servername journalctl 日志内容太多了。现在让我们把涉及 sshd 的信息过滤出来： ssh servername journalctl | grep sshd ssh是一种通过命令行远程访问计算机的方式。 此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下： ssh servername 'journalctl | grep sshd | grep \"Disconnected from\"' | less 多出来的引号是什么作用呢？这么说吧，系统日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 less 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了： $ ssh servername 'journalctl | grep sshd | grep \"Disconnected from\"' > ssh.log $ less ssh.log 过滤结果中仍然包含不少没用的数据。这时候来了解一下sed这个工具。 sed是一个基于文本编辑器ed构建的”流编辑器” 。在sed中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 s，即替换命令，例如我们可以这样写： cat ssh.log | sed 's/.*Disconnected from //' 上面这段命令中，我们使用了一段简单的正则表达式。 正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。s 命令的语法如下：s/REGEX/SUBSTITUTION/, 其中 REGEX 部分是我们需要使用的正则表达式，而 SUBSTITUTION 是用于替换匹配结果的文本。 正则表达式 正则表达式-语法 正则表达式 正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： /.*Disconnected from /。正则表达式通常以（尽管并不总是）/开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有： .除换行符之外的”任意单个字符” *匹配前面字符零次或多次 +匹配前面字符一次或多次 [abc]匹配 a, b 和 c 中的任意一个 (RX1|RX2)任何能够匹配RX1 或 RX2的结果 ^行首 $行尾 sed 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加\\才能使其具有特殊含义。或者，您也可以添加-E选项来支持这些匹配。 可以发现/.*Disconnected from /这个正则表达式可以匹配任何以若干个任意字符开头，并在后面跟着“Disconnected from ”的字符串。但是在默认情况下，*和+是贪婪模式，它会尽可能多的匹配文本。所以有时候会出现如下情况： $ cat ssh.log | head -n1 Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth] $ cat ssh.log | sed 's/.*Disconnected from //' | head -n1 46.97.239.16 port 55920 [preauth] 可见其将IP地址前的用户名（Disconnected from）也匹配并替换了，这样一来就达不到我们想要的结果了。 解决方法是换用一个正则表达式来匹配一整行： sed -E 's/^.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \\[preauth\\])?$//' 让我们借助正则表达式在线调试工具 regex debugger 来理解这段表达式。 开始的部分和之前是一样的，然后匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（[^ ]+ 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀[preauth]，最后再匹配行尾。 使用上面的命令会将日志内容全部替换成空字符串，输出显示的仅为一片空白。 那我们需要将用户名输出显示，就要使用“捕获组（capture group）”来完成。 捕获组表示用来记住该值并在之后使用。在正则表达式中，任何圆括号括起来的表达式就是这样的一个捕获组。 被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如\\1、\\2、\\3等等。 sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' 为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。 正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。 回到数据整理 现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户： $ cat ssh.log | sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c sort会对其输入数据进行排序。uniq -c 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名： $ cat ssh.log | sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 sort -n 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 -k1,1 则表示“仅基于以空格分割的第一列进行排序”。,n 部分表示“仅排序到第n个部分”，默认情况是到行尾。 如果我们希望得到登录次数最少的用户，我们可以使用 head 来代替tail。或者使用sort -r来进行倒序排序。 只获取用户名并按逗号分隔并列显示： $ cat ssh.log | sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | awk '{print $2}' | paste -sd, 我们可以利用paste命令来合并行(-s)，并指定一个分隔符进行分割 (-d)，那awk的作用又是什么呢？ awk - 另外一种流编辑器 awk 其实是一种编程语言，只不过它碰巧非常善于处理文本。 awk 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行。 在代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。 awk '{print $2}'的意思即为对每一行文本打印其第二部分，在这里则是指用户名。 让我们统计一下所有以 c 开头，以 e 结尾，且仅登录过一次的用户。 $ cat ssh.log | sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | awk '$1 == 1 && $2 ~ /^c.*e$/ {print $0} 这次我们为awk指定了一个匹配模式串（也就是{...}前面的那部分内容）。该匹配要求文本的第一部分需要等于 1（这部分刚好是uniq -c得到的计数值），然后其第二部分必须满足给定的一个正则表达式。~就是表示用来匹配后面的正则表达式，告诉awk后面开始是正则语法。代码块中的内容则表示打印整行。 不过，既然 awk 是一种编程语言，那么则可以这样统计行数： BEGIN { rows = 0 } $1 == 1 && $2 ~ /^c[^ ]*e$/ { rows += $1 } END { print rows } BEGIN 也是一种模式，它会匹配输入的开头（ END 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 grep 和 sed ，因为 awk 就可以解决所有问题。 分析数据 想做数学计算也是可以的！例如这样，您可以将每行的数字加起来： | awk '{print $1}' | paste -sd+ | bc -l 下面这种更加复杂的表达式也可以： echo \"2*($(data | paste -sd+))\" | bc -l 您可以通过多种方式获取统计数据。如果已经安装了R语言，st 是个不错的选择： $ cat ssh.log | sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | awk '{print $1}' | R --slave -e 'x R 也是一种编程语言，它非常适合被用来进行数据分析和绘制图表。这里我们不会讲的特别详细， 您只需要知道summary可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。 如果您希望绘制一些简单的图表， gnuplot 可以帮助到您： $ cat ssh.log | sed -E 's/^.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | gnuplot -p -e 'set boxwidth 0.5; plot \"-\" using 1:xtic(2) with boxes' 命令行参数处理 有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 xargs 即可实现： $ rustup toolchain list | grep nightly | grep -vE \"nightly-x86\" | sed 's/-x86.*//' | xargs rustup toolchain uninstall xargs接受若干行输出，并将它们转化为参数形式。 整理二进制数据 虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。 $ ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh servername 'gzip -d | tee copy.jpg' | feh - 课后练习 学习一下这篇简短的交互式正则表达式教程。 原网站是全英文教程，不过都很简短明晰。不过不知道为什么不能交互了，所以我将网址换成了它的汉化版。 网站上的教程做完基本能熟悉正则表达式的基本用法。下面我放一下自己的答案（答案不止一种）： # 课程 1. [a-c]+ 2. \\d\\d\\d 3. ^.*\\. 4. ^[cmf]+[an]+$ 5. ^[^b]og$ 6. ^[^a-z]\\w*$ 7. ^waz{2,}up$ 8. a+b*c+ 9. ^\\d+ files? found\\?$ 10. ^\\d.\\s+.*$ 11. ^\\w+\\:\\s?successful$ 12. ^(.*)\\.pdf$ 13. ^(.*\\s+(\\d+))$ 14. (\\d{3,4})x(\\d{3,4}) 15. ^.*(cats|dogs)$ 16. .* # 问题 1. ^-?\\d+(,\\d+)*(\\.\\d+)?(e\\d+)?$ 2. 1?\\s*-?\\(?(\\d{3})\\)?\\s*-?\\d{3}\\s*-?\\d{4} 3. ^([\\w\\.]*) 4. ^\\ 更多资源：在线学正则表达式 统计words文件 (/usr/share/dict/words) 中包含至少三个a且不以's结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ sed的y命令，或者 tr 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很有挑战性的问题：哪个组合从未出现过？ Linux sed 命令详解 Linux tr 命令详解 统计个数： $ cat /usr/share/dict/words | tr \"[:upper:]\" \"[:lower:]\" | grep -E \"^(.*a){3}.*[^'s]$\"| wc -l 在上面的单词中统计出现频率前三的末尾两个字母： $ cat /usr/share/dict/words | tr \"[:upper:]\" \"[:lower:]\" | grep -E \"^(.*a){3}.*[^'s]$\" | sed -E \"s/.*([a-z]{2})$/\\1/\" | sort | uniq -c | sort | tail -n3 词尾两字母组合种类数量： $ cat /usr/share/dict/words | tr \"[:upper:]\" \"[:lower:]\" | grep -E \"^(.*a){3}.*[^'s]$\" | sed -E \"s/.*([a-z]{2})$/\\1/\" | sort | uniq | wc -l 未出现过的组合： # 枚举所有组合 #!/bin/bash for i in {a..z}; do for j in {a..z}; do echo ${i}${j} done done ```bash occur.sh $ ./all.sh > all.txt $ cat /usr/share/dict/words | tr \"[:upper:]\" \"[:lower:]\" | grep -E \"^(.a){3}.'s$\" | sed -E \"s/.*([a-z]{2})$/\\1/\" | sort | uniq | sort > occur.txt $ diff --unchanged-group-format='' 3. 进行原地替换听上去很有诱惑力，例如： `sed s/REGEX/SUBSTITUTION/ input.txt > input.txt`。但是这并不是一个明智的做法，为什么呢？还是说只有 sed是这样的? 查看 `man sed` 来完成这个问题 不能使用`sed s/REGEX/SUBSTITUTION/ input.txt > input.txt`的操作，因为会先执行`> input.txt`将后者清空。所以前面一个`input.txt`在还没有被 `sed` 处理时已经为空了。在使用正则处理文件前最好是首先备份文件。 ```bash sed -i.bak s/REGEX/SUBSTITUTION/ input.txt > input.txt 上面的命令会自动创建一个后缀为 .bak 的备份文件。 找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 journalctl 。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作： Logs begin at ... 和 systemd[577]: Startup finished in ... journalctl 默认只会保存最近一次启动的日志。我们需要修改设置来允许 journalctl 记录多次开机的日志。 $ sudo vi /etc/systemd/journald.conf 设置Storage=persistent： 然后手动重启多次系统，收集数据： 使用 journalctl 和 grep 筛选出系统启动数据： 观察发现带有kernel即内核的条目即为系统的真正启动时间，进一步筛选： 编写脚本getlog.sh来获取最近十次的启动时间数据： #!/bin/bash for i in {0..9}; do journalctl -b-$i | grep \"Startup finished in\" done $ ./getlog.sh > starttime.txt sed的正则有许多语法都不支持，因此这里只用最基本的语法。 #获取最长时间 $ cat starttime.txt | grep \"systemd\\[1\\]\" | sed -E \"s/.*=\\ (.*)s\\.$/\\1/\" | sort | tail -n1 #获取最短时间 $ cat starttime.txt | grep \"systemd\\[1\\]\" | sed -E \"s/.*=\\ (.*)s\\.$/\\1/\" | sort -r | tail -n1 #平均数（注意 awk 要使用单引号） $ cat starttime.txt | grep \"systemd\\[1\\]\" | sed -E \"s/.*=\\ (.*)s\\.$/\\1/\" | paste -sd+ | bc -l | awk '{print $1/10}' # 中位数 $ cat starttime.txt | grep \"systemd\\[1\\]\" | sed -E \"s/.*=\\ (.*)s\\.$/\\1/\" | sort | paste -sd\\ | awk '{print ($5+$6)/2}' 查看之前三次重启启动信息中不同的部分(参见journalctl的-b选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用sed '0,/STRING/d' 来删除STRING匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用uniq)。最后，删除所有出现过3次的内容（因为这些内容是三次启动日志中的重复部分）。 将上面的getlog.sh简单修改为： #!/bin/bash for i in {0..2}; do #获取最近三次的启动日志 journalctl -b-$i | sed '0,/Startup finished/d' done 然后输入下列命令： $ ./getlog.sh > last3time.txt 去除开头的时间戳： $ cat last3time.txt | sed -E \"s/.*al\\ (.*)/\\1/\" | head -n10 重复记录输入行并对其计数，并删除所有出现过3次的内容： #注意 uniq 只能过滤相邻的行，所以必须先排序 $ cat last3time.txt | sed -E \"s/.*al\\ (.*)/\\1/\" | sort | uniq -c | sort | awk '$1!=3 { print }' 在网上找一个类似这个或者这个的数据集。或者从这里找一些。使用 curl 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么pup可能会更有帮助。对于JSON类型的数据，可以试试jq。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。 emmmmmm，我看了看两个数据集，内容都还挺多的，第三个网站是自己去里面列出的网址找数据集。 curl命令会遍历整个html文件并下载，使用grep和sed命令筛选将会得到一长串包含正则表达式的命令。题目中提到的工具确实能使数据筛选更高效快速。 题目中说的一条指令，可以包含长串的函数，那样来说确实是一条，但是不够美观。 因本人懒，且虚拟机无法连接上以上网站，所以这里不作解答。 Copyright © www.itheima.com/javase 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-08-12 21:58:17 "},"MIT Missing Semester 笔记/Shell-Tools-and-Scripting.html":{"url":"MIT Missing Semester 笔记/Shell-Tools-and-Scripting.html","title":"Shell Tools And Scripting","keywords":"","body":"官方文档: https://missing.csail.mit.edu/ 官方文档中文翻译: https://missing-semester-cn.github.io/ Shell 脚本 本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。 在bash中的变量赋值语法为foo=bar，访问变量中的值，其语法为$foo。 需要注意的是，foo = bar（使用空格隔开）是不能正确工作的，因为解释器会调用程序foo并将=和bar作为参数。 在bash、zsh、sh中，空格是用于分隔参数的保留字符，使用空格可能会造成混淆。 Bash中的字符串通过'和\"分隔符来定义，但是它们的含义并不相同。以'定义的字符串为原义字符串，其中的变量不会被转义，而\"定义的字符串会将变量值进行替换。 $ foo=bar $ echo \"$foo\" #打印 bar $ echo '$foo' #打印 $foo 和其他大多数的编程语言一样，Bash 也支持if，case，while和for这些控制流关键字。同样地， Bash 也支持函数，它可以接受参数并基于参数进行操作。 以下是一个简单的函数定义，该函数位于mcd.sh文件中： mcd() { mkdir -p \"$1\" cd \"$1\" } 该函数会创建一个文件夹并将当前目录切换到该文件夹。 +++ bash中的一些特殊变量 $0 #当前 Shell的名称（在命令行直接执行时）或者脚本名（在脚本中执行时） $1 ~ $9 #第一个参数及其之后的参数 $@ #脚本的所有参数值 $# #脚本的参数数量 $? #上一个命令的返回值。返回值是0，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。 $$ #当前 Shell 的进程ID 或者当前脚本的进程ID $_ #上一个命令的最后一个参数 !! #完整的上一个命令 +++ Bash 变量 source命令会在当前bash环境下读取并执行对应文件中的命令。source mcd.sh将mcd.sh文件内的内容添加到 Shell 中，即将函数mcd添加到了 Shell 中。 然后该函数即可在 Shell 中直接使用。 ~$: source mcd.sh ~$: mcd test ~/test$: cd .. Bash 脚本入门 ;;;id1 官方笔记 退出码可以搭配&&（与操作符）和||（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（short-circuiting）。 同一行的多个命令可以用;分隔。程序 true 的返回码永远是0，false 的返回码永远是1。 $ false || echo \"Oops, fail\" # Oops, fail $ true || echo \"Will not be printed\" # $ true && echo \"Things went well\" # Things went well $ false && echo \"Will not be printed\" # $ false ; echo \"This will always run\" # This will always run 另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 命令替换（command substitution）实现。 当您通过$( CMD )这样的方式来执行CMD这个命令时，它的输出结果会替换掉 $( CMD )。例如，如果执行for file in $(ls)，Shell首先将调用ls，然后遍历得到的这些返回值。 还有一个冷门的类似特性是进程替换（process substitution），会执行 CMD 并将结果输出到一个临时文件中，并将替换成临时文件名。这在我们希望返回值通过文件而不是STDIN（标准输入）传递时很有用。例如，diff 会显示文件夹 foo 和 bar 中文件的区别。 $ foo=$(pwd) $ echo $foo # 输出当前目录路径 $ echo \"We are in $(pwd)\" # We are in 当前目录路径 $ cat ;;; 包含上述所有 bash 变量的程序example.sh： #!/bin/bash echo \"Starting program at $(date)\" echo \"Running program $0 with $# args with pid $$\" for file in $@; do grep foobar $file > /dev/null 2> /dev/null # 如果没有找到，则 grep 退出状态为 1 # 我们将 STDOUT(>) 和 STDERR (2>) 重定向到 Null，因为我们并不关心这些信息 # 2> 是用来重定向 STDERR 的，因为 STDOUT 和 STDERR 是分离的 if [[ $? -ne 0 ]]; then # 比较运算符 -ne (Non Equal)，代表不等于 echo \"File $file does not have any foobar, adding one\" echo \"# foobar\" >> $file fi done 运行该脚本： user@localhost:~/missing/shell_tools$ ./example.sh mcd.sh test2.sh Starting program at Sun July 23 23:51:13 CST 2022 Running program ./example.sh with 2 args with pid 11920 File test2.sh does not have any foobar, adding one 通配 当执行脚本时，我们经常需要提供形式类似的参数。Bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的通配（globbing） 通配符：当你想要利用通配符进行匹配时，你可以分别使用?和*来匹配一个或任意个字符。 大括号{}：当你有一系列的指令，其中包含一段公共子串时，可以用大括号来自动展开这些命令。这在批量移动或转换文件时非常方便。 convert image.{png,jpg} # 会展开为 convert image.png image.jpg cp /path/to/project/{foo,bar,baz}.sh /newpath # 会展开为 cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath # 也可以结合通配使用 mv *{.py,.sh} folder # 会移动所有 *.py 和 *.sh 文件 mkdir foo bar # 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件 touch {foo,bar}/{a..h} touch foo/x bar/y # 比较文件夹 foo 和 bar 中包含文件的不同 diff y 使用环境变量来解析脚本 脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。 例如： #!/usr/bin/python import sys for arg in reversed(sys.argv[1:]): print(arg) 但是，如果解释器不放在目录/bin，脚本就无法执行了。为了保险，可以写成下面这样： #!/usr/bin/env python env命令总是指向/usr/bin/env文件，或者说，这个二进制文件总是在目录/usr/bin。 #!/usr/bin/env NAME这个语法的意思是，让 Shell 查找$PATH环境变量里面第一个匹配的NAME。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。 +++ Shell函数和脚本的一些不同点 函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 Shebang 是很重要的。 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。 函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 export将环境变量导出，并将值传递给环境变量。 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。 +++ Shell 工具 find 指令 # . 表示当前目录 # 查找所有名称为 src 的文件夹 find . -name src -type d # 查找所有文件夹路径中包含test的python文件 find . -path '*/test/*.py' -type f # 查找前一天修改的所有文件 find . -mtime -1 # 查找所有大小在500k至10M的tar.gz文件 find . -size +500k -size -10M -name '*.tar.gz' #对搜索结果执行 rm 操作 find . -name '*.tmp' -exec rm {} \\; find 命令的 7 种用法 grep 命令 在文件中搜索： $ grep foobar mcd.sh # foobar 文件夹中递归的搜索，需要 flag -R： $ grep -R foobar . ./example.sh: grep foobar $file > /dev/null 2> /dev/null ./example.sh: echo \"File $file does not have any foobar, adding one\" ./example.sh: echo \"# foobar\" >> $file ./mcd.sh:# foobar ./test2.sh:# foobar grep 命令常见用法 课程中介绍到了ripgrep（rg）命令，但这是非内置命令，并不具有通用性，故不作记录。需要了解的请自行在网络上搜索。 history 命令 history命令允许您以程序员的方式来访问 Shell 中输入的历史命令。这个命令会在 STDOUT 中打印 Shell 中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给grep进行模式搜索。 history | grep find会打印包含find子串的命令。 linux的history命令 组合键ctrl + R可以从指令输入历史中搜索对应的指令。 +++ fzf 命令 摘抄自Github上的学习笔记 安装：https://github.com/junegunn/fzf#using-linux-package-managers 使用： $ cat example.sh | fzf 可以进行模糊搜索。 安装的时候可以选择绑定到 ctrl + R 指令，从而在历史搜索时启用 fzf +++ 课后习题 阅读 man ls ，然后使用ls 命令进行如下操作： 所有文件（包括隐藏文件） 文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) 文件以最近访问顺序排序 以彩色文本显示输出结果 $ man ls $ ls -a $ ls -h $ ls --color=auto $ ls -alhS --color=auto ls命令常见使用方法 编写两个bash函数marco和polo执行下面的操作。 每当你执行marco时，当前的工作目录应当以某种形式保存，当执行polo时，无论现在处在什么目录下，都应当cd回到当时执行marco的目录。 为了方便debug，你可以把代码写在单独的文件marco.sh中，并通过source marco.sh命令，（重新）加载函数。 #!/bin/bash marco(){ echo \"$(pwd)\" > $HOME/marco_pwd.log echo \"save pwd $(pwd)\" } polp(){ cd \"$(cat \"$HOME/marco_pwd.log\")\" } $ vim marco.sh $ source marco.sh $ marco save pwd /home/missing/shell_tools ~/missing/shell_tools$ cd / /$ polo ~/missing/shell_tools$ 假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。 #!/usr/bin/env bash n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo \"Something went wrong\" >&2 echo \"The error was using magic numbers\" exit 1 fi echo \"Everything went according to plan\" #! usr/bin/env bash count=1 while true do ./buggy.sh > stdout.log 2> stderr.log if [[ $? -ne 0 ]]; then echo \"failed after $count times\" cat stderr.log break fi ((count++)) done 本节课我们讲解的find命令中的-exec参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如tar则需要从参数接受输入。这里我们可以使用xargs命令，它可以使用标准输入中的内容作为参数。 例如ls | xargs rm会删除当前目录中的所有文件。 您的任务是编写一个命令，它可以递归地查找文件夹中所有的 HTML 文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看xargs的参数-d） $ mkdir html_folder $ cd html_folder $ touch {1..10}.html $ mkdir html $ cd html $ touch test.html $ cd .. $ find . -type f -name \"*.html\" | xargs -d '\\n' tar -cvzf html.zip xargs命令详解 tar命令常用方法 （进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？ find . -type f -mmin -60 -print0 | xargs -0 ls -lt | head -10 Copyright © www.itheima.com/javase 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-08-01 23:42:15 "},"MIT Missing Semester 笔记/Vim.html":{"url":"MIT Missing Semester 笔记/Vim.html","title":"Vim","keywords":"","body":"Vim 介绍 这还要介绍？只要是学编程的应该都知道，不知道的请在网络上搜索。 编辑模式 Normal：在文件中移动光标进行浏览或编辑。正常启动 Vim 就是进入 Normal 模式，在此模式下可用其他组合键切换其他模式，在其他模式下按下Esc回到 Normal 模式。 Insert：在 Normal 模式下按下i键进入。可插入文本。 Replace：在 Normal 模式下按下大写R键进入。在该模式下会输入直接覆盖掉文本。 Visual (Line/Block)：在 Normal 模式下按v键进入 Visual 模式，按Shift+v（大写V）进入 Visual line 模式，按Ctrl+v进入 Visual block 模式。可选中文本块。 Command-line：在 Normal 模式下按下:键进入。用于执行命令。 基本操作 vi命令详解 缓存，标签页，窗口 Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在多个窗口打开，甚至在同一个标签页内的多个窗口打开。这个功能其实很好用，比如在查看同一个文件的不同部分的时候。 Vim 默认打开一个标签页，这个标签也包含一个窗口。 命令行（command-line） :q退出当前窗口 :w保存文件 :wq保存并退出当前窗口 :qa退出所有窗口 :e {name of file}打开要编辑的文件 :ls显示打开的缓存 :help {topic}打开帮助，一般格式如下:help :w，:help w（:w和w是不一样的，后者表示你在 Normal 模式下按w键）。在帮助下输入:q，回车后返回 Normal 模式。 :sp分离（seperate）窗口。 Vim 的接口其实是一种编程语言 “接口”即是指用户与其交互的方式、中介物。 Vim 中的键入操作 （以及他们的助记名） 本身是命令， 这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。 移动 基本移动: hjkl（左， 下， 上， 右）（这个操作有点反直觉，也可以用箭头来移动，按自己的习惯就可以） 词： w（下一个词），b（词初），e（词尾） 行：0（行初），^（第一个非空格字符），$（行尾） 屏幕：H（屏幕首行），M（屏幕中间），L（屏幕底部） 翻页：Ctrl+u（上翻），Ctrl+d（下翻） 文件：gg（文件头），G（文件尾） 行数：:{行数}或者{行数}G({行数}为行数) 杂项：%（找到配对，比如括号或者 / / 之类的注释对） 查找：f{字符}，t{字符}，F{字符}，T{字符} 向前(小写)/向后(大写) 查找(f)/到 (t，在该字符的前一位或后一位) 在本行的{字符} ,/;用于导航匹配 搜索:/{正则表达式}，n/N用于导航匹配。搜索结束之后输入enter转入到第一个结果位置，之后输入n跳转到下一个结果位置，shift + n跳转到前一个结果位置。 编辑 i 进入插入模式 O / o 在之上/之下插入行 d{移动命令} 删除 {移动命令} 例如， dw 删除词，d$ 删除到行尾，d0 删除到行头，dd删除整行 c{移动命令} 改变 {移动命令} 例如， cw 改变词，cc改变整行 比如 d{移动命令} 再 i x 删除字符（等同于 dl） s 替换字符（等同于 xi） 可视化模式 + 操作 选中文字， d 删除 或者 c 改变 u 撤销 (Undo)，Ctrl+r 重做 (Redo) y 复制 (yank) （ Vim 内的复制粘贴默认不使用操作系统的剪切板） 例如yy复制整行，yw复制词，y4l复制右侧的4个字符 p 粘贴 ~ 改变字符的大小写 a 追加 计数 3w 向前移动三个词 5j 向下移动5行 7dw或者d7w 删除7个词 修饰符 修饰符有 i，表示“内部”或者“在内”，和 a， 表示“周围”。 ci( 改变当前括号内的内容 ci[ 改变当前方括号内的内容 da' 删除一个单引号字符串，包括单引号 演示 这里是一个有问题的 fizz buzz 实现： （ fizz buzz 是一种输出 1 到 n 的练习，当数字能被 3 整除时，输出 fizz；当数字能被 5 整除时，输出buzz；当数字能同时被 3 和 5 整除时，输出fizzbuzz。若上述条件均没有满足，则直接输出数字） def fizz_buzz(limit): for i in range(limit): if i % 3 == 0: print('fizz') if i % 5 == 0: print('fizz') if i % 3 and i % 5: print(i) def main(): fizz_buzz(10) 我们会修复以下问题： 主函数没有被调用 从 0 而不是 1 开始 在 5 的整数倍的时候打印 “fizz” 在 15 的整数倍的时候在不同行打印 “fizz” 和 “buzz” 采用硬编码的参数 10 而不是从命令控制行读取参数 解决： 主函数没有被调用 G 文件尾 o 向下打开一个新行 输入 if __name__ == '__main__': main() 从 0 而不是 1 开始 搜索 /range ww 向前移动两个词 i 插入文字， “1, ” ea 在 limit 后插入， “+1” 在新的一行 “fizzbuzz” jj$i 插入文字到行尾 加入 “, end=''” jj. 重复第二个打印（在 Vim 中，按下.会重复之前的操作） jjo 在 if 下打开一行 加入 “else: print()” 在 5 的整数倍的时候打印 “fizz” 搜索 /fizz，按n找到下一个匹配的结果 ci'改变两个单引号中间的内容为“buzz” 命令控制行参数 ggO 向上打开 “import sys” /10 ci( 更改括号内容为 “int(sys.argv[1])” 展示详情请观看课程视频。比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。 自定义 Vim Vim 由一个位于 ~/.vimrc 的文本配置文件（包含 Vim 脚本命令）。 你可能会启用很多基本 设置。 我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 在这儿下载我们的设置，然后将它保存成 ~/.vimrc. Vim 能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在GitHub 上共享的设置文件，比如，课程讲师们的 Vim 设置 (Anish, Jon (uses neovim), Jose)。 有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件，而是阅读和理解它，然后采用对你有用的部分。 扩展 Vim Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你不需要在 Vim 使用一个插件管理器（从 Vim 8.0 开始）。你可以使用内置的插件管理系统。只需要创建一个 ~/.vim/pack/vendor/start/ 的文件夹，然后把插件放到这里（比如通过 git clone）。 以下是一些我们最爱的插件： ctrlp.vim: 模糊文件查找 ack.vim: 代码搜索 nerdtree: 文件浏览器 vim-easymotion: 魔术操作 我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件 (Anish, Jon, Jose) 来看看我们使用的其他插件。 浏览 Vim Awesome 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim plugins”。 Vim 进阶 宏 q{字符} 来开始在寄存器{字符}中录制宏 q停止录制 @{字符} 重放宏 宏的执行遇错误会停止 {计数}@{字符}执行一个宏{计数}次 宏可以递归 首先用q{字符}q清除宏 录制该宏，用 @{字符} 来递归调用该宏 （在录制完成之前不会有任何操作） 课后习题 完成 vimtutor。 在 Linux 的终端里输入： $ vimtutor 即可打开 Vim 安装时自带的教程。 下载我们提供的 vimrc，然后把它保存到 ~/.vimrc。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。[:heavy_check_mark:check]{.label .success} 安装和配置一个插件： ctrlp.vim. [:heavy_check_mark:check]{.label .success} 练习使用 Vim, 在你自己的机器上重做演示。[:heavy_check_mark:check]{.label .success} 下个月用 Vim 完成所有的文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”时， 尝试求助搜索引擎，很有可能有一个更好的方式。 在其他工具中设置 Vim 快捷键 （见上面的操作指南）。 [:heavy_check_mark:check]{.label .success} 进一步自定义你的 ~/.vimrc 和安装更多插件。（在本人虚拟机的 Ubuntu 系统没有找到 .vimrc 文件，这里直接挪用官方答案） 安装插件最简单的方法是使用 Vim 的包管理器，即使用 vim-plug 安装插件： 安装 vim-plug $ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 修改 ~/.vimrc call plug#begin() Plug 'preservim/NERDTree' #需要安装的插件 NERDTree Plug 'wikitopian/hardmode' #安装 hardmode ..... # 更多插件 call plug#end() 在 vim 命令行中执行:PlugInstall （高阶）用 Vim 宏将 XML 转换到 JSON (例子文件)。 $ curl -O https://missing-semester-cn.github.io/2020/files/example-data.xml $ vim example-data.xml 操作： Gdd, ggdd 删除第一行和最后一行 这里表示按下Esc键，空格和逗号不表示分隔，有什么就输入什么。 格式化最后一个元素的宏 （寄存器为e） 跳转到第一个有 的行 qe^r\"f>s\": \"fq 格式化一个人的宏（寄存器为p） 跳转到有第一个有 的行 qpS{j@eA,j@ejS},q 格式化一个人然后转到另外一个人的宏（寄存器为q） 跳转到有第二个有 的行 qq@pjq 执行宏到文件尾 999@q 手动移除最后的 , 然后在开头行和末尾行加上 [ 和 ] 分隔符。 $ mv example-data.xml example-data.json $ vim example-data.json Copyright © www.itheima.com/javase 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-08-12 21:55:41 "}}